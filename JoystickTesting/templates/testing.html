<!DOCTYPE html>
<html>
<head>
<!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<link rel="stylesheet" type="text/css" href="style.css">

<title>Page Title</title>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="col-lg-8  offset-lg-2">
            <img src="video_feed" width="50%"><!--width="100%"><!--multipart/x-mixed-replace; boundary=frame-->
        </div>
    </div>
</div>
<!-- <script language="javascript" type="text/javascript" src="/functions.js"></script>
    <script language="javascript">
		/*
      function send_command(cmd) {
        document.getElementById('hints').firstChild.nodeValue = "Send command: " + cmd;
        AJAX_get('/?action=command&command='+ cmd)
      }

      function AJAX_response(text) {
        document.getElementById('hints').firstChild.nodeValue = "Got response: " + text;
      }*/

    </script> -->

<h1>My First Heading</h1>
<p>My first paragraph.</p>
<p id="demo"></p>

<script>
document.getElementById("demo").innerHTML = "Hello JavaScript!";

//var gamepads = {};
var haveEvents = 'ongamepadconnected' in window;
var controllers = {};
var countPrint = 0;
var valsUpdatedGlob = false;
var updateLoopCount = 0;
var updateLoopMax = 2;//1;//5;

var axesDirs = [[0,0],[0,0]];
//var camAxisDirs = [0,0];
var buttonVals = [0,0,0,0,0,0,0,0,0];//9 buttons
function connecthandler(e) {
  addgamepad(e.gamepad);
}

function addgamepad(gamepad) {
  controllers[gamepad.index] = gamepad; // adds GamePad gamepad to controllers array, in index of gamepad's index

  var d = document.createElement("div");
  d.setAttribute("id", "controller" + gamepad.index);

  var t = document.createElement("h1");
  t.appendChild(document.createTextNode("gamepad: " + gamepad.id));
  d.appendChild(t);

  var b = document.createElement("div");
  b.className = "buttons";
  for (var i = 0; i < gamepad.buttons.length; i++) {
    var e = document.createElement("span");
    e.className = "button";
    //e.id = "b" + i;
    e.innerHTML = i;
    b.appendChild(e);
  }

  d.appendChild(b);

  var a = document.createElement("div");
  a.className = "axes";

  for (var i = 0; i < gamepad.axes.length; i++) {
    var p = document.createElement("progress");
    p.className = "axis";
    //p.id = "a" + i;
    p.setAttribute("max", "2");
    p.setAttribute("value", "1");
    p.innerHTML = i;
    a.appendChild(p);
  }

  d.appendChild(a);

  // See https://github.com/luser/gamepadtest/blob/master/index.html
  var start = document.getElementById("start");
  if (start) {
    start.style.display = "none";
  }

  document.body.appendChild(d);
  requestAnimationFrame(updateStatus);
}
function disconnecthandler(e) {
	
  removegamepad(e.gamepad);
}

function removegamepad(gamepad) {
	axesDirs = [[0,0],[0,0]];
	buttonVals = [0,0,0,0,0,0,0,0,0];
	sendVals();
  var d = document.getElementById("controller" + gamepad.index);
  document.body.removeChild(d);
  delete controllers[gamepad.index];
}

function updateStatus() {
  if (!haveEvents) {
    scangamepads();
  }
  
  
  var i = 0;
  var j;
	var valsUpdated = false;
	var usingGameController = false;
	var buttonNum = 0;
	//var buttonsUpdated = false;
  for (j in controllers) {
	if(usingGameController && j>0){
		break;
	}else if(j>1){
		break;
	}
	
    var controller = controllers[j];
	
	if(controller.axes.length==4){
		usingGameController = true;
	}
	//just checks for 4 axis to see if its a game controller
	
	
    var d = document.getElementById("controller" + j);
    var buttons = d.getElementsByClassName("button");


	//buttons
	
	//todo: need to account for gamepad vs physical interface
	
	//for physical interface,
	//need to account for some buttons being on one "controller"
	//and some being on the other
	
	//physical interface:
	//9 buttons
	//left controller: 3 buttons
	//right controller: 6 buttons
	
	
	//for now: assuming game controller
	//will break if use physical 
	
	
	/*xbox button layout: (expand to see)
	//a = 0
	//b = 1
	//x = 2
	//y = 3
	//left bumper = 6
	//right bumper = 5
	//left trigger = 6
	//right trigger = 7
	//select = 8
	//start = 9
	//click left stick = 10
	//click right stick = 11
	//dpad up = 12
	//dpad down = 13
	//dpad left = 14
	//dpad right = 15
	//home = 16
	*/
	
	//wait, does the physical interface even have "buttons", 
	//or does it treat them all as axes?
	//if the latter, need to rework code in axes part to account for this
	
	
	//todo: tell when a button val has changed (like with axes), to know when to send message
    //axesUpdated, but for buttons
	
	
	//todo: tell when axes or buttons updated, updated variable
	//after, work out how to differentiate button press from toggle from hold on this end?
	for (i = 0; i < controller.buttons.length; i++) {
		if(!usingGameController && ((i > 2 && j == 0) || (i >5 && j == 1))){
			//left joystick: movement, 3 buttons.
			//right joystick: camera, 6 buttons.
			break;
		}else if(usingGameController && i>8){
			break;
		}
		//console.log(controller.buttons.length); game controller: 17
      var b = buttons[i];
      var val = controller.buttons[i];
      var pressed = val == 1.0;
      if (typeof(val) == "object") {
        pressed = val.pressed;
        val = val.value;
      }

      var pct = Math.round(val * 100) + "%";
      b.style.backgroundSize = pct + " " + pct;
		var tempButtonVal = 0;
      if (pressed) {
		tempButtonVal = 1;
        b.className = "button pressed";
      } else {
		tempButtonVal = 0;
        b.className = "button";
      }
	  if(buttonVals[buttonNum] != tempButtonVal){
		//console.log("button val: " + buttonVals[buttonNum] + ", tempButtonVal: " + tempButtonVal);
		valsUpdated = true;
		valsUpdatedGlob = true;
	  }
	  buttonVals[buttonNum] = tempButtonVal;
	  buttonNum+=1;
    }
	/*countPrint+=1;
	if(countPrint == 100){//prints once every 100 loops
		countPrint = 0;
		//console.log("button values: " + buttonVals);
		//console.log(buttonVals.join('') + '/' + axesDirs[0].join(' ') + '/' + axesDirs[1].join(' ')); //creates a string out of array

	}*/
	
	//axes
	
	var axis0 = 0;
    var axes = d.getElementsByClassName("axis");
	//console.log(controller.axes.length);
	//break;
    for (i = 0; (i+1) < controller.axes.length; i+=2) {
		if(i>2){
			break;
		}
		if(!usingGameController && i>1){
			break;
		}
		//var axesUpdated = false;
		//var movAxesUpdate = false;
		/*if(i>1){
			if(i>3 || j>0){
				break;
			}else{
				usingGameController = true;
			}
		}*/
		
		
		
		var a1 = axes[i];
		a1.innerHTML = i + ": " + controller.axes[i].toFixed(4);
		a1.setAttribute("value", controller.axes[i] + 1);
		var a2 = axes[i+1];
		const i_plus = i+1;
		a2.innerHTML = i_plus + ": " + controller.axes[i+1].toFixed(4);
		a2.setAttribute("value", controller.axes[i+1] + 1);
		/*if(j == 0 && i<2){//movement
			if(controller.axes[i]>0.2){
				if(i == 0){
					axis0 = 1;
				}else if(i==1){
					moveAxis(j, axis0, 1);//forward();
				}
			}else if(controller.axes[i]<-0.2){
				if(i == 0){
					axis0 = -1;
				}else if(i == 1){
					moveAxis(j, axis0, -1);//backward();
				}
			}
			else{
				if(i == 1){
					moveAxis(j, axis0, 0);
				}
			}
			
			
		}if(j==1 || (usingGameController && i>1 && j==0)){
			var axisNum = i;
			if(usingGameController){
				axisNum -= 2;
			}
			
			if(controller.axes[i]>0.2){
				moveAxis(1, axisNum, 1);
			}else if(controller.axes[i]<-0.2){
				moveAxis(1, axisNum, -1);
			}else{
				moveAxis(1, axisNum, 0);
			}
			
			
		}*/
		var axesSetNum = j; //0 is movement, 1 is camera
		if(usingGameController && i>1){
			axesSetNum = 1;
		}
		
		//var axesVals = [];
		var prevVals = axesDirs[axesSetNum];
		var count;
		for(count = 0; count < 2; count++){
			var tempVal;
			if(controller.axes[count+i]>0.5){
				//axesVals[count] = 1;
				tempVal = 1;
			}else if(controller.axes[count+i]<-0.5){
				//axesVals[count] = -1;
				tempVal = -1;
				//console.log("axis negative! AxesSetNum: " + axesSetNum + ", count: " + count + ", tempNum: " + tempVal);
			}
			else{
				
				//axesVals[count] = 0;
				tempVal = 0;
				
			}
			if(/*axesVals[count]*/tempVal != prevVals[count]){
				//axesUpdated = true;
				valsUpdated = true;
				valsUpdatedGlob = true;
				axesDirs[axesSetNum][count] = tempVal;
			}
		}
		
		/*if(axesUpdated){
			//console.log("axesSetNum: " + axesSetNum + ", axisDirs: " + axesDirs[0][0] + ", " + axesDirs[0][1] + ", " + axesDirs[1][0] + ", " + axesDirs[1][1])
			//axesDirs[axesSetNum][0] = axesVals[0];
			//axesDirs[axesSetNum][1] = axesVals[1];
			
			moveAxis(axesSetNum, axesDirs[axesSetNum][0], axesDirs[axesSetNum][1]);
		}*/


		//if(j == 0){// && i<2){//movement
			//var contNum = j;
			//var axisNum = i;
			
			
			
			/*if(i>1){
				if(usingGameController){
					axisNum -= 2;
					
					contNum = 1;
				}else{
					break;
				}
			}else if(j==1){
				
			}*/
			
			/*
			if(controller.axes[i]>0.2){
				if(axisNum == 0){
					if(
					axis0 = 1;
				}else if(axisNum==1){
					moveAxis(contNum, axis0, 1);//forward();
				}
			}else if(controller.axes[i]<-0.2){
				if(axisNum == 0){
					axis0 = -1;
				}else if(axisNum == 1){
					moveAxis(contNum, axis0, -1);//backward();
				}
			}
			else{
				if(axisNum == 1){
					moveAxis(contNum, axis0, 0);
				}
			}
			
			
			if(i==1){
				axis0 = 0;
			}*/
			
		//}
	  //camAxesUpdated
	  //movAxesUpdated
	  //only send xml request if the respective axes have been updated
	  //can tell if been updated if the new values are dif than the stored values.
	  
	  
    }
  }
	/*if(buttonsUpdated){
	
		console.log(buttonVals.join('') + '/' + axesDirs[0].join('') + '/' + axesDirs[1].join('')); //creates a string out of array
	}*/

	//updateLoopCount+=1;
	/*
	if(false && updateLoopCount == updateLoopMax){//updates once every 5 loops
		updateLoopCount = 0;
		if(valsUpdatedGlob){
			sendVals();
			valsUpdatedGlob = false;
		}
		//console.log("button values: " + buttonVals);
		//console.log(buttonVals.join('') + '/' + axesDirs[0].join(' ') + '/' + axesDirs[1].join(' ')); //creates a string out of array

	}*/
	
	if(valsUpdated){
		//console.log(buttonVals.join('') + '/' + axesDirs[0].join('') + '/' + axesDirs[1].join('')); //creates a string out of array
		sendVals();
		// make it so that can only send vals once every 5 loops? 
		//as in, always counting, can only send on the fifth loop, but still stores values on the other 4
		//that way, pressing a button and then another button within 4 loops would only send 1 update, with both button updates 
		//if pressed and let go within the 5 loop period, input is removed, but nobody needs to press it that fast? 
		//could cause weird delay with axes though, 0-4 loop delay.
		//maybe only implement this if there ends up being too many requests sent.
		//CAN ALSO PLAYTEST DIFFERENT VERSIONS, one with this delay implemented, one without
		//if neither works, look into hosting on a web server? can handle requests much faster. flask freeze, host on github?
	
	}
	//console.log(" ");
  requestAnimationFrame(updateStatus);
  /*ANIMATIONFRAME, TODO
  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
  
  Warning: Be sure to always use the first argument 
	(or some other method for getting the current time) 
	to calculate how much the animation will progress in a frame, 
	otherwise the animation will run faster on high refresh rate screens. 
  Check the example below for a way to do this.
  */
  /*
  function step(timestamp) {
	  if (start === undefined) {
		start = timestamp;
		}
	  const elapsed = timestamp - start;

	  if (previousTimeStamp !== timestamp) {
		// Math.min() is used here to make sure the element stops at exactly 200px
		const count = Math.min(0.1 * elapsed, 200);
		element.style.transform = 'translateX(' + count + 'px)';
	  }

	  if (elapsed < 2000) { // Stop the animation after 2 seconds
		previousTimeStamp = timestamp
		window.requestAnimationFrame(step);
	  }
	}
  */
}

function scangamepads() {
  var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
  for (var i = 0; i < gamepads.length; i++) {
    if (gamepads[i]) {
      if (gamepads[i].index in controllers) {
        controllers[gamepads[i].index] = gamepads[i];
      } else {
        addgamepad(gamepads[i]);
      }
    }
  }
}

window.addEventListener("gamepadconnected", connecthandler);
window.addEventListener("gamepaddisconnected", disconnecthandler);

if (!haveEvents) {
 setInterval(scangamepads, 500);
}


/*function forward()
{
	xmlhttp.open("GET","move/forward",true);
	xmlhttp.send();
}*/

/*
for button values,
console.log(buttonVals.join(''); //creates a string out of array
can join the button vals into a string, then send the string to the python file
can also do this with axes! and instead of "for_right" and whatnot,
just send the numbers, (all values, axes and buttons) as a string,
can parse in python file by just determining the values at each index of the string

*********************************************************************
e.g. cmd = buttonVals.join('') + axesDirs[0].join('')+axesDirs[1].join('');
*********************************************************************
need to adjust for the action var
make a new "moveAxis" function, sendVals

alternatively, maybe can figure out direction on the html end
 (eg for_right for move, center for camx and up for camy),
then pass the enum value to the python file? so less data to pass?
	also wouldn't have to deal with possibility of multiple directions at once?

*/

function sendVals(){
	//moveAxis(0,0,0);
	//return;
	// cmd = buttonVals.join('') + axesDirs[0].join('')+axesDirs[1].join('');
	//console.log("sending vals: " + buttonVals.join('') + '/' + axesDirs[0].join(' ') + '/' + axesDirs[1].join(' ')); //creates a string out of array
	//maybe have html determine movement axes values, send that (e.g. send "2" for FOR_RIGHT, etc)
	//instead of having python file determine it on python's end?
	//only need for carDirection
/*
class CarDirection(Enum):
    NONE = 0
    FORWARD = 1
    FOR_RIGHT = 2
    TURN_RIGHT = 3
    BACK_RIGHT = 4
    BACK = 5
    BACK_LEFT = 6
    TURN_LEFT = 7
    FOR_LEFT = 8
*/

	//Y is inverted?
	var carDir = 0;
	switch(axesDirs[0][1]){
		case -1://forward Y
			switch(axesDirs[0][0]){
				case 1: //forward right(?)
					carDir = 2;
					break;
				case -1: //forward left(?)
					carDir = 8;
					break;
				case 0: //forward
					carDir = 1;
					break;
				default:
					console.log("wrong axis value!");
			}
			break;
		case 1://backward Y
			switch(axesDirs[0][0]){
				case 1: //backward right(?)
					carDir = 4;
					break;
				case -1: //backward left(?)
					carDir = 6;
					break;
				case 0: //backward
					carDir = 5;
					break;
				default:
					console.log("wrong axis value!");
			}
			break;
		case 0://neutral Y
			switch(axesDirs[0][0]){
				case 1: //turn right(?)
					carDir = 3;
					break;
				case -1: //turn left(?)
					carDir = 7;
					break;
				case 0: //centered
					carDir = 0;
					break;
				default:
					console.log("wrong axis value!");
			}
			break;
		default:
			console.log("wrong axis value!");
	}		
	
/*
class CamDirection(Enum):
    NONE = 0
    RIGHT = 1
    LEFT = 2
    UP = 3
    DOWN = 4
*/
	var camDir = [0,0];
	switch(axesDirs[1][0]){
		case 1: //right
			camDir[0] = 1;
			break;
		case -1://left
			camDir[0] = 2;
			break;
		case 0://none
			camDir[0] = 0;
			break;
		default:
			console.log("wrong axis value!");
	}
	
	switch(axesDirs[1][1]){
		case -1: //up
			camDir[1] = 3;
			break;
		case 1://down
			camDir[1] = 4;
			break;
		case 0://none
			camDir[1] = 0;
			break;
		default:
			console.log("wrong axis value!");
	}	
	//console.log("sending vals: " + buttonVals.join('') + '/' + axesDirs[0].join(' ') + "(carDir: " + carDir + ")" + '/' + axesDirs[1].join(' ') + " camDir: " + camDir.join('')); //creates a string out of array
	var message = "buttons=" + buttonVals.join('') + "&car=" + carDir + "&cam=" + camDir.join('');
	console.log("sending vals: " + message);//.join('') + '/' + carDir + '/' + camDir.join('')); //creates a string out of array
	
	//first 9 values: button vals, in order
	//then a /
	//then car direction enum
	//then a /
	//then x and y cam direction enums, no spaces between.
	var xmlhttp;
	xmlhttp=new XMLHttpRequest();
	xmlhttp.open("HEAD","/data?" + message,true);
	xmlhttp.onerror = checkData;
	
	function checkData()
	{
		/*xmlhttp.open("HEAD",action+cmd,true);
		xmlhttp.onerror=null;*/ //for if request failed, 
		//so means robot didn't recieve data?
		//need to test on robot.
		console.log(xmlhttp.readyState);
		if(xmlhttp.readyState == 4){
			//axesDirs[gamepad][0] = xAxis;
			//axesDirs[gamepad][1] = yAxis;
		}
		
	}
	xmlhttp.timeout = 600;
	xmlhttp.ontimeout = blah;
	xmlhttp.send();



	//moveAxis(0,0,0);
}

function moveAxis(gamepad, xAxis, yAxis)//val_1, val_2)
{	
	//return;
	/*const one = 'Hello, ';
	const two = 'how are you?';
	const joined = `${one}${two}`;
	console.log(joined); // "Hello, how are you?"
	
	const action;*/
	//console.log(gamepad);
	var action = "";
	if(gamepad == 0){
		action = "move/";
	//use strings to modify the xmlhttp.open call; 
	//if gamepad == 0, "move", else if gamepad == 1, "camera"
	//cam might be able to have each axis called separately, maybe. not sure
	}else if(gamepad == 1){
		action = "camera/";
		//return;
	}
	var cmd = "";
	
	
	
	//if(gamepad == 0){
		//return;
		//var xAxis = val_1;
		//var yAxis = val_2;
		
		if(yAxis == -1){
			if(xAxis == 1){//forward right(?)
				cmd = "for_right";
			}else if(xAxis == -1){//forward left(?)
				cmd = "for_left";
				//xmlhttp.open("GET",action+"for_left",true);
				//xmlhttp.send();
			}else{//forward
				cmd = "forward";
				//xmlhttp.open("GET",action+"forward",true);
				//xmlhttp.send();
			}
		}else if(yAxis == 1){
			if(xAxis == 1){//backward right(?)
				cmd = "back_right";
				//xmlhttp.open("GET",action+"back_right",true);
				//xmlhttp.send();
			}else if(xAxis == -1){//backward left(?)
				cmd = "back_left";
				//xmlhttp.open("GET",action+"back_left",true);
				//xmlhttp.send();
			}else{//backward
				cmd = "back";
				//xmlhttp.open("GET",action+"back",true);
				//xmlhttp.send();
			}
		}else{
			if(xAxis == 1){//turn right(?)
				cmd = "right";
				//xmlhttp.open("GET",action+"right",true);
				//xmlhttp.send();
			}else if(xAxis == -1){//turn left(?)
				cmd = "left";
				
			//	xmlhttp.open("GET",action+"left",true);
				//xmlhttp.send();
			}else{//centered
				cmd = "center";
				//xmlhttp.open("GET",action+"center",true);
				//xmlhttp.send();
			}
		}
		if(cmd != ""){
			//console.log("sending cmd");
			//console.log("axisDirs: " + axesDirs[0][0] + ", " + axesDirs[0][1] + ", " + axesDirs[1][0] + ", " + axesDirs[1][1])
			var xmlhttp;
			xmlhttp=new XMLHttpRequest();
			xmlhttp.open("HEAD",action+cmd,true);
			/*if(gamepad==0 && (xAxis!= 0 || yAxis !=0)){
				xmlhttp.onreadystatechange = checkData;
				console.log("gamepad: " + gamepad + ", xAxis: " + xAxis + ", yAxis: " + yAxis);
			}else{
				xmlhttp.onreadystatechange = null;
			}*/
			xmlhttp.onerror = checkData;
			
			function checkData()
			{
				/*xmlhttp.open("HEAD",action+cmd,true);
				xmlhttp.onerror=null;*/ //for if request failed, 
				//so means robot didn't recieve data?
				//need to test on robot.
				console.log(xmlhttp.readyState);
				if(xmlhttp.readyState == 4){
					//axesDirs[gamepad][0] = xAxis;
					//axesDirs[gamepad][1] = yAxis;
				}
				
			}
			xmlhttp.timeout = 600;
			xmlhttp.ontimeout = blah;
			xmlhttp.send();
			//sample(100);
			/*for(var a = 0; a < 300; a++){
			}*/
			/*var timedOut = false;
			setTimeout(function(){
				timedOut = true;
			}, 100); 
			while(!timedOut){
				console.log("jkl;");
			}*/
		}
		
	//}
	/*else if(gamepad==1){
		var axisNum = val_1;//x is 0, y is 1?
		var direction = val_2;
		

		if(axisNum == 0){
			//console.log("axisNum: " + axisNum);
			/*xmlhttp.open("GET","xAxis/right",true);
			xmlhttp.send();
			return;* /
			if(direction>0){
				xmlhttp.open("GET","camera/right",true);
				xmlhttp.send();
			}else if(direction<0){
				xmlhttp.open("GET","camera/left",true);
				xmlhttp.send();
			}else{
				xmlhttp.open("GET","camera/centerX",true);
				xmlhttp.send();
			}
		}else{
			//console.log("axisNum: " + axisNum);
			/*xmlhttp.open("GET","yAxis/right",true);
			xmlhttp.send();
			return;* /
			if(direction<0){
				xmlhttp.open("GET","camera/up",true);
				xmlhttp.send();
			}else if(direction>0){
				xmlhttp.open("GET","camera/down",true);
				xmlhttp.send();
			}else{
				xmlhttp.open("GET","camera/centerY",true);
				xmlhttp.send();
			}
		}
		
		
	}*/
}
function delay(delayInms) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(2);
    }, delayInms);
  });
}

async function sample(time) {
  console.log('a');
  console.log('waiting...')
  let delayres = await delay(time);
  console.log('b');
}

function blah(){
	console.log("timeout");
}
/*
function gamepadHandler(event, connecting) {
  var gamepad = event.gamepad;
  // Note:
  // gamepad === navigator.getGamepads()[gamepad.index]

  if (connecting) {
    gamepads[gamepad.index] = gamepad;
	//console.log("Gamepad connected from index %d: %s",
		//gamepad.index, gamepad.id);
	var gp = navigator.getGamepads()[gamepad.index];
	console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
		gp.index, gp.id,
		gp.buttons.length, gp.axes.length);
	//gameLoop();
  } else {
    delete gamepads[gamepad.index];
	console.log("Gamepad disconnected from index %d: %s",
    gamepad.index, gamepad.id);
  }
}
/*
	Chrome does things differently here. Instead of constantly storing the gamepad's latest state in a variable 
	it only stores a snapshot, so to do the same thing in Chrome you have to keep polling it and then only use the 
	Gamepad object in code when it is available. We have done this below using setInterval();
	once the object is available the gamepad info is outputted, the game loop is started, and the interval is cleared using clearInterval. 
	Note that in older versions of Chrome Navigator.getGamepads() is implemented with a webkit prefix. We attempt to detect and handle both 
	the prefixed version and the standard version of the function for backwards compatibility.
* /
window.addEventListener("gamepadconnected", function(e) { gamepadHandler(e, true); }, false);
window.addEventListener("gamepaddisconnected", function(e) { gamepadHandler(e, false); }, false);*/
</script>

<style>
.axes {
  padding: 1em;
}

.buttons {
  margin-left: 1em;
}

/*meter*/.axis {
  min-width: 200px;
  margin: 1em;
}

.button {
  display: inline-block;
  width: 1em;
  text-align: center;
  padding: 1em;
  border-radius: 20px;
  border: 1px solid black;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAAXNSR0IArs4c6QAAAAxJREFUCNdjYPjPAAACAgEAqiqeJwAAAABJRU5ErkJggg==);
  background-size: 0% 0%;
  background-position: 50% 50%;
  background-repeat: no-repeat;
}

.pressed {
  border: 1px solid red;
}

.touched::after {
  content: "touch";
  display: block;
  position: absolute;
  margin-top: -0.2em;
  margin-left: -0.5em;
  font-size: 0.8em;
  opacity: 0.7;
}
</style>





</body>
</html>
